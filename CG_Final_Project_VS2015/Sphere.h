#pragma once
#ifndef SPHERE_H
#define SPHERE_H

#include <glad/glad.h>
#include <GLFW/glfw3.h>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include <shader_s.h>
#include <iostream>
#include <vector>

#define pi 3.1415926

class Sphere {
public:
	/* Sphere Data */
	glm::vec3 center;
	float radius;
	std::vector<float> vertices;
	unsigned int sphereVAO;
	unsigned int sphereTexture;

	/* Functions */
	Sphere() {

	}

	Sphere(int divide, float radius, std::string picturePath) {
		createSphere(divide, radius, picturePath);
		this.radius = radius;
		center = glm::vec3(0.0f, 0.0f, 0.0f)
	}

	void Draw(Shader shader, const glm::mat4& transform, const glm::mat4& view, const glm::mat4& projection, unsigned int depthCubemap = 0) {
		glm::vec4 temp = transform * glm::vec4(0.0f, 0.0f, 0.0f, 1.0f)
		center.x = temp.x;
		center.y = temp.y;
		center.z = temp.z;
		glActiveTexture(GL_TEXTURE0);
		glBindTexture(GL_TEXTURE_2D, sphereTexture);
		if (depthCubemap != 0) {
			glActiveTexture(GL_TEXTURE1);
			glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap);
		}
		shader.use();
		shader.setMat4("projection", projection);
		shader.setMat4("view", view);
		shader.setMat4("transform", transform);
		glBindVertexArray(sphereVAO);//??VAO
		glDrawArrays(GL_TRIANGLE_STRIP, 0, vertices.size() / 8);//??????
	}
private:
	/* Functions */
	void createSphere(int divide, float radius, std::string picturePath) {
		float altitude;//��??
		float altitudeDelta;//?????��??
		float azimuth;//????
		float ex;//???x????
		float ey;//???y????
		float ez;//???z????

		//????????divide?????????????????????��???
		for (int i = 0; i <= divide; i++) {
			altitude = (float)(pi / 2.0 - i * pi / divide);//??????????��???
			altitudeDelta = (float)(pi / 2.0 - (i + 1) * pi / divide);//??????????��???
																	  //?????????divide????????????????��????????��?????????????
			for (int j = 0; j <= divide; j++) {
				azimuth = (float)(j * (pi * 2) / divide);//???????
				ex = (float)(cos(altitude) * cos(azimuth));
				ey = (float)sin(altitude);
				ez = (float)-(cos(altitude) * sin(azimuth));
				//????azimuth??????��???altitude???????
				vertices.push_back(radius * ex);
				vertices.push_back(radius * ey);
				vertices.push_back(radius * ez);
				//????azimuth??????��???altitude???????????
				vertices.push_back(j / (float)divide);
				vertices.push_back(i / (float)divide);
				//????azimuth??????��???altitude???????????
				vertices.push_back(radius * ex - vertices[0]);
				vertices.push_back(radius * ey - vertices[1]);
				vertices.push_back(radius * ez - vertices[2]);

				ex = (float)(cos(altitudeDelta) * cos(azimuth));
				ey = (float)sin(altitudeDelta);
				ez = (float)-(cos(altitudeDelta) * sin(azimuth));
				//????azimuth??????��???altitudeDelta???????
				vertices.push_back(radius * ex);
				vertices.push_back(radius * ey);
				vertices.push_back(radius * ez);
				//????azimuth??????��???altitudeDelta???????????
				vertices.push_back(j / (float)divide);
				vertices.push_back((i + 1) / (float)divide);
				//????azimuth??????��???altitudeDelta???????????
				vertices.push_back(radius * ex - vertices[0]);
				vertices.push_back(radius * ey - vertices[1]);
				vertices.push_back(radius * ez - vertices[2]);
			}
		}
		//????
		unsigned int sphereVBO;//?????????
		glGenVertexArrays(1, &sphereVAO);//???????VAO????
		glGenBuffers(1, &sphereVBO);//???????VBO????
		glBindVertexArray(sphereVAO);//??VAO
									 //????????�`????????��?OpengGL???
		glBindBuffer(GL_ARRAY_BUFFER, sphereVBO);//????????????VBO???GL_ARRAY_BUFFER?????
		glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertices.size(), &vertices[0], GL_STATIC_DRAW);//????????????????points_vertices???????????????
		//???????????
		//��?????????0
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(0 * sizeof(float)));//????????????
		glEnableVertexAttribArray(0);
		//???????????1
		glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));//????????????
		glEnableVertexAttribArray(1);
		//?????????????2
		glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(5 * sizeof(float)));//????????????
		glEnableVertexAttribArray(2);

		//*******????1*******
		glGenTextures(1, &sphereTexture);//?????????????????????????????
		glBindTexture(GL_TEXTURE_2D, sphereTexture);//??????
		//????????????????????????????
		//?????????
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);    // set texture wrapping to GL_REPEAT (default wrapping method)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
		//???��?????
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		//????????
		int width;//?????
		int    height;//?????
		int    nrChannels;//???????????
		stbi_set_flip_vertically_on_load(true);
		unsigned char *data = stbi_load(picturePath.c_str(), &width, &height, &nrChannels, 0);
		//????????
		if (data) {
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
			glGenerateMipmap(GL_TEXTURE_2D);
		}
		else {
			std::cout << "Failed to load texture,please check the path!" << std::endl;
		}
		stbi_image_free(data);//??????
	}
};

#endif